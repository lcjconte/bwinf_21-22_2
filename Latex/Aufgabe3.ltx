\documentclass[a4paper,10pt,ngerman]{scrartcl}
\usepackage{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[a4paper,margin=2.5cm]{geometry}

% Die nächsten drei Felder bitte anpassen:
\newcommand{\Name}{Team: ??? / Name} % Teamname oder eigenen Namen angeben
\newcommand{\TeamId}{???}
\newcommand{\Aufgabe}{Aufgabe3: \LaTeX-Dokument}

% Kopf- und Fußzeilen
\usepackage{scrlayer-scrpage}
\setkomafont{pageheadfoot}{\textrm}
\ifoot{\Name}
\cfoot{\thepage}
\chead{\Aufgabe}
\ofoot{Team-ID: \TeamId}

% Für mathematische Befehle und Symbole
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
\DeclarePairedDelimiter\abs{\mid}{\mid}
\newcommand{\rar}{\rightarrow}

% Für Bilder
\usepackage{graphicx}

% Für Algorithmen
\usepackage{algpseudocode}

% Für Quelltext
\usepackage{minted}

% Diese beiden Pakete müssen als letztes geladen werden
%\usepackage{hyperref} % Anklickbare Links im Dokument
\usepackage{cleveref}

% Daten für die Titelseite
\title{\Aufgabe}
\author{\Name\\Team-ID: \TeamId}
\date{\today}

\begin{document}

\maketitle
\tableofcontents


% Hier kommt der Inhalt hin!

\section{Lösungsidee}
\subsection{Das Problem}
Gegeben ist ein String $\alpha$ aus $N$ Hexadezimalziffern, wobei jeder Ziffer eine einzigartige Kombination aus bis zu sieben Segmenten zugewiesen wird. Durch das 'Umlegen' dieser Segmente, welches maximal $M$ erfolgen darf, soll nun der größtmöglichste Hexadezimalstring gebildet werden. \\
Der Lösungsidee beruht auf folgender Abstraktion des String-Umformungsvorgangs:

\subsection{Wie man sich die schrittweise Umformung des Strings vorstellen kann}
Um eine Ziffer in eine andere zu transformieren müssen Segmente umgelegt werden. Dabei gibt es für zwei Ziffern x und y, Segmente die in x sind, wo sie in y nicht mehr sein dürfen, und in y sind, ohne in x zu sein.\\
\begin{gather*}
b_{x\rar y} := (\text{Anzahl der Segmentpositionen, die nur in x belegt sind}, \\ \text{Anzahl der Segmentpositionen, die nur in y belegt sind}) \\
\implies b_{B\rar D} = (1, 1)
\end{gather*}
An dieser Stelle muss hinzugefügt werden, dass die Segmentdarstellung der Ziffern, auch als Binärdarstellung mit 7-bits, gedacht werden kann. Ordnet man die Segmentplätze wie in Abbildung 1, kann jeder Ziffer eine 7 bit Zahl zugeordnet werden.
$B \rar D$ entspricht dann $0101111 \rar 0011111$ \\
Solange die zwei Komponenten von $b_{x \rar y}$ gleich sind, intern also an genauso vielen Positionen Segmente entfernt, wie hinzugefügt werden müssen, kann die Transformation ohne Beachtung des Rest des Strings erfolgen. Sie kostet dann $b_{x \rar y}[0]$ Umlegungen.\\
Es gibt aber auch Fälle, wie zum Beispiel $b_{2 \rar 7}=(2, 1)$, in denen die Segmentanzahlen der zwei Ziffern nicht gleich sind. Solche Transformationen sind immer noch möglich, da Transformationen mehrerer Ziffern eines Strings sich ausbalancieren können. Beispiel:\\
$``2F``  \rar  ``C0``$, wobei $b_{2 \rar C} = (3, 1) \text{ und } b_{F \rar 0} = (1, 3)$\\
Die erste Transformation muss zwei Segmente nach außen abgeben. Sie kann trotzdem stattfinden, da gleichzeitig die zweite Transformation zwei Segmente von außen aufnehmen muss. \\
Man kann sich für einen Substring $\gamma$ während des Transformationsvorgangs eine zusäzliche Information g, das Gleichgewicht des Strings, vorstellen. Diese ist anfänglich 0, wird jedoch von Transformationen verändert. Was das heißen soll kann man am Beispiel erkennen:
\begin{align*}
\gamma =  ``2F`` \quad  g = 0\\
\xrightarrow{2 \rar C} \gamma = ``CF`` \quad g = 2\\
\xrightarrow{F \rar 0} \gamma = ``C0`` \quad g = 0 
\end{align*}
Solange das vorgestellte Gleichgewicht nicht null ist, ist der String ungültig, da er teilweise aus nichtexistenten Segmenten besteht, oder Segmente ins Nichts abgelegt wurden.
Eine Transformation $x \rar y$ beeinflusst das Gleichgewicht des Systems folgendermaßen:
\begin{equation*}
b_{x \rar y} = (w, z) \implies g_{x \rar y} = w-z
\end{equation*}
Man kann sich g als Ablage vorstellen, die positiv ist, wenn der String weniger Segmente als zuvor besitzt. \\
Kann man einer Transformationen Umlegungskosten zuweisen? Die Transformation $x \rar y$ kostet zuerst einmal die inneren Kosten, also $\min{(w, z)}$. Die Umlegungen, die in ''Zusammenarbeit'' mit einer anderen Transformation stattfindeen, werden nur halb gezählt, da sie eben bei beiden Transformationen betrachtet werden. Für die Kosten gilt also: 
\begin{equation*}
k_{x \rar y} = \min{(w, z)}+\frac{1}{2}\abs{w-z} \quad \text{(Immer mit $(w, z) = b_{x \rar y})$}
\end{equation*}
Es muss an dieser Stelle hinzugefügt werden, dass das gerade erklärte System mit den Transformationen, der vorgestellten ''Segmentbank'' und den rationalen Kosten, nicht beschreibt wie am Schluss die Segmente tatsächlich umgelegt werden. Es wird nur im Verfahren den Ergebnisstring zu finden benötigt. \\
Damit ein String nach mehrern Transformationen, die dazu führen, dass $g=0 \land k \leq M$, auch im Sinne der Aufgabenstellung gültig ist muss noch folgendes gezeigt werden.

\subsection{Weshalb eine Ziffer nie komplett leer ist}
Es soll gezeigt werden, dass es immer möglich ist Strings gleicher Segmentanzahlen umzuformen, ohne dabei eine Ziffer je komplett zu leeren. 

\subsection{Ansatz}
Die Lösung wird Ziffer für Ziffer zusammengesetzt. Damit der resultierende String so groß wie möglich ist werden in absteigender Reihenfolge die möglichen bedeutendsten Ziffern getestet. Der allererste Schritt für $\alpha=``D24``$ ist also zu bestimmen, was die minimalen Kosten für $``D24`` \rar ``F``$ sind. Der Suffix ist unbestimmt, da seine lexikographische Größe weniger wichtig als die der bedeutendsten Stelle ist. $D \rar F$ resultiert in g = 1 für den Suffix. Dieser Suffix muss also ausgehend von g=1 "balanciert" werden, also mit minimalen Kosten so umgeformt werden, dass g zu 0 wird. Die minimalen Kosten für die balancierung des Suffixes sein $f(i, g)$ wobei i die bedeutendste Stelle des Suffixes ist und g das Ungleichgewicht. Wenn $k_{D \rar F} + f(1, 1) \leq M$ wäre, könnte man jetzt die 0. Stelle der Lösung auf F festlegen, doch im Beispiel ist das nicht der Fall. Also geht man weiter zu Umformung in die nächstkleinere Ziffer E und so weiter.\\
Zusammengefasst wird die Lösung also Ziffer für Ziffer, beginnend bei der bedeutendsten Stelle, zusammengesetzt. Ausgehend von den Kosten für die bisherigen Transformationen und dem aus diesen resultierten Ungleichgewicht, wird die aktuelle Stelle in die größtmöglichste Ziffer transformiert. Dass die Kosten am Schluss nicht M übersteigen und dass der resultierende String gleich viele Segmente wie das Original enthält, wird von f garantiert. Da jedesmal die größtemöglichste Ziffer gewählt wird, ist auch das Ergebnis maximal.

\subsection{f(i, g)}
\begin{gather*}
f(N, g) = \begin{cases}
0\text{, falls }g=0\\
\infty \text{, ansonsten}
\end{cases} \quad \text{0-basierte Indexe}\\
f(i, g) = \min{(\infty, \min_{y \in Z}{(k_{x \rar y}+f(i+1, g+g_{x \rar y}))})} \\
Z\text{ ist die Menge der Ziffern} \quad x\text{ ist die Ziffer im Original}
\end{gather*}
Da die Definitionsmenge von f relativ begrenzt ist, kann man mit dynamic programming die Ergebnisse Memoisieren. Der Speicherbedarf ist dann $O(N^2)$ und die Laufzeit $O(N^2 \cdot \abs{Z})$.

\subsection{Zusammenfassung}
Für den gesamten Algorithmus ergibt sich somit für das Finden des Lösungsstrings die Laufzeit $O(N^2 \cdot \abs{Z})$
Hat man einmal den Lösungsstring kann man in linearer Laufzeit die Umlegungsschritte berechnen. 




\section{Umsetzung}
Für die Umsetzung wurde Rust verwendet

\section{Erweiterungen}

\section{Beispiele}

\section{Quellcode}

\end{document}
