\documentclass[a4paper,10pt,ngerman]{scrartcl}
\usepackage{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[a4paper,margin=2.5cm]{geometry}

% Die nächsten drei Felder bitte anpassen:
\newcommand{\Name}{Team: ??? / Name} % Teamname oder eigenen Namen angeben
\newcommand{\TeamId}{???}
\newcommand{\Aufgabe}{Aufgabe3: \LaTeX-Dokument}

% Kopf- und Fußzeilen
\usepackage{scrlayer-scrpage}
\setkomafont{pageheadfoot}{\textrm}
\ifoot{\Name}
\cfoot{\thepage}
\chead{\Aufgabe}
\ofoot{Team-ID: \TeamId}

% Für mathematische Befehle und Symbole
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}


% Für Bilder
\usepackage{graphicx}

% Für Algorithmen
\usepackage{algpseudocode}

% Für Quelltext
\usepackage{minted}

% Diese beiden Pakete müssen als letztes geladen werden
%\usepackage{hyperref} % Anklickbare Links im Dokument
\usepackage{cleveref}

% Daten für die Titelseite
\title{\Aufgabe}
\author{\Name\\Team-ID: \TeamId}
\date{\today}

\begin{document}

\maketitle
\tableofcontents


% Hier kommt der Inhalt hin!

\section{Lösungsidee}
\subsection{Ansatz}
Gegeben ist ein String aus $N$ Hexadezimalziffern, wobei jeder Ziffer eine einzigartige Kombination aus bis zu sieben Segmenten zugewiesen wird. Durch das 'Umlegen' dieser Segmente, welches maximal $M$ erfolgen darf, soll nun der größtmöglichste Hexadezimalstring gebildet werden. \\
Anstatt Umlegungen einzelner Segmente zu betrachten werden im Folgenden immer Transformationen von einer vollständigen Ziffer zu einer vollständigen Ziffer betrachtet. Zum Beispiel 2 -> 7. Wenn man die einzelnen Segmentplätze wie in Abbildung 1 ordnet, kann jeder Ziffer eine 7 bit Zahl zugeordnet werden. Ist das Bit an Position p an, dann ist das p-te Segment bei der Darstellung der Ziffer auch an. 2 -> 7 entspricht dann 1011101 -> 1010010. Die zwei Bit-Strings sind an 3 Positionen gleich. An einer Position besitzt nur 7 ein aktives Segment und an zwei besitzt nur 2 ein aktives Segment. \\
Die zur Umformung des gesamten Strings relevanten Informationen sind für jede einzelne Transformation vollständig im 'Balancetupel' enthalten:
\begin{gather*}
b_{a->c} := (\text{Anzahl der Segmente, die nur in a an sind}, \text{Anzahl der Segmente, die nur in c an sind}) \\
\implies b_{2->7} = (2, 1)
\end{gather*}
An b erkennt man, wie viele Segmente dem Rest des Strings entnommen werden müssen, wie viele der Rest des Strings aufnehmen muss und wie viele innerhalb der Ziffer verschoben werden müssen um die Transformation zu ermöglichen. \\
Die genaueren Informationen dazu enthält der 'Kostentupel':
\begin{gather*}
k_{a->c} := (\mid b_{a->c}_0 - b_{a->c}_1 \mid + add, b_{a->c}_0 - b_{a->c}_1) \\
\implies k_{2->7} = (1 + add, 1)
\end{gather*}
Der Kostentupel enthält an erster Stelle die "Kosten", also Umlegungen, die die Transformation benötigt, und an zweiter Stelle die Anzahl an über oder unterflüssigen Segmenten. Die Kosten setzen sich erst einmal aus den internen Umlegungen zusammen und dann noch aus den Umlegungen, die erst durch die Transformation einer Ziffer an einer anderen Stelle im String ermöglicht werden. Die gesamte Lösungsidee beruht auf dem Gedanken, dass man bei der Suche nach dem Lösungs-String einen 'hypotetischen' String mittels einzelner 

\subsection{Weshalb eine Ziffer nie komplett leer ist}
Ausbreiten, dann in Reihenfolge


\section{Umsetzung}
Für die Umsetzung wurde Rust verwendet

\section{Erweiterungen}

\section{Beispiele}

\section{Quellcode}

\end{document}
